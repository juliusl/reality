use reality::v2::prelude::*;

mod plugin;
mod println;
use println::*;
use reality_derive::engine;

/// This example shows how to consume extensions and components described with runmd w/ the reality compiler,
///
/// # Background
///
/// The storage method/architecture the compiler uses is based on the ECS pattern (Entity Component System), and uses the
/// `specs` crate as the implementation. An entity is an id that is used to index components within a `World` data structure.
/// More implementation details about `specs` and the ECS pattern can be found in the [`specs` crate documentation](https://specs.amethyst.rs/docs/tutorials/).
///
/// The runmd data model consists of two main components, `Identifier`'s and `Properties`'s. An entity with
/// these two components is referred to as an `Object`. The compiler converts blocks of runmd into objects and
/// stores the components in World storage.
///
/// This has several benefits, but the most notable are:
///
/// - At runtime this data will be arranged in a contiguous manner, so that iterating over data benefits from cpu-caching.
/// - Systems can "join" different component storages into a tuple of only the components that are relevant to the system.
/// - When an entity is deleted, all components attached to the entity are automatically cleaned up.
///
/// Each group of blocks compiled by the compiler produces a "Build", which is state the includes a log indexing identifiers to entities.
/// This is analagous to object files generated by a typical compiler. A build can be exported to a .toml file that can be loaded by the compiler in-place of the
/// file that contained the original runmd blocks.
///
/// # Linking components to objects
///
/// The runmd data model consists of several "attributes" such as, `.symbol` or `.int`. This indicates to the
/// compiler how each line of runmd should converted into the data-model.
///
/// The root runmd block can be used to extend this data-model by defining custom attributes and extensions. This allows
/// the compiler to be extended to map externally provided components to entities.
///
/// The following example defines a "Plugin" root attribute. Comments inline describe each line.
///
/// ```runmd
/// +  .symbol   Plugin     # Defining a symbol root called Plugin w/ common extensions
/// <> .map                 # Indicates that a property will be a list of property names
/// <> .format              # Indicates that the property will be used for formatting
/// ```
///
/// Next, the `plugin` attribute can be used to define components.
///
/// The following defines a component called `Println`.
///
/// **Note** -- Extensions defined previously are used to annotate the properties defined by `Println`.
///
/// ```runmd
/// + .plugin   Println     # This plugin prints to stdout and stderr
/// : fmt       .symbol     # List of properties that can be formatted
/// : stderr    .symbol     # Lines that will be printed to stderr
/// : stdout    .symbol     # Lines that will be printed to stdout
/// <map>       .fmt        # Plugin will map each name found in the `fmt` property to it's value
/// <format>    .stdout     # Plugin will parse each line for formatting tokens
/// <format>    .stderr     # Plugin will parse each line for formatting tokens
/// <format>    .println    # Plugin will parse each line for formatting tokens
/// ```
///
/// This plugin can then be used in the following way,
///
/// **Note** -- The `example` block identifier will not be rendered by the markdown renderer.
///
/// ```runmd example
/// +                       .symbol     Example                   # Creating a simple root called Example,
/// <plugin>                .println    
/// : name                  .fmt        World
/// : othername             .fmt        World 2
/// :                       .stdout     Hello {name}
/// :                       .stdout     Hello {othername}
/// <plugin>                .println    part2
/// : name                  .fmt        Other World
/// :                       .stdout     Hello {name}
/// ```
///
/// Even though the plugin attribute only defines two extensions in this example, it can be extended to include additional extensions in subsequent builds.
///
/// The rest of the source code of this example will demonstrate how to link new component types w/ the compiler.
///
#[reality::parse_docs]
#[tokio::main]
async fn main() -> Result<()> {
    // Uncomment to see logging
    // enable_logging();

    let mut compiler = Compiler::new().with_docs();

    // This function is generated from the runmd blocks in the above documentation
    let _ = compile_runmd_main(&mut compiler)?;

    // Println uses `derive(Runmd)` to generate code that the compiler can use to link it to entities
    compiler.link(Println::new())?;

    // Also generated is a SystemData struct that can be used to load "instances" of this component
    // For demonstration purposes this loop will call instances, but typically this can be used from a System or via DispatchRef
    let instances = compiler
        .as_ref()
        .system_data::<PrintlnProvider>()
        .state_vec::<PrintlnInstance>()
        .iter()
        .map(|c| c.0)
        .collect::<Vec<_>>();
    
    async fn __entrypoint2(disp: DispatchRef<'_, Properties>) -> DispatchResult<'_> {
        todo!()
    }

    for i in instances {
        __entrypoint2(compiler.dispatch_ref(i)).await?;
    }
    
    engine!([Println] {
        /// 
        /// 
        greet => {
            greet.enable_async()
                .call().await?
                .greet().await
        },
        setup => {
            setup.enable_async()
                .call().await?
                .enable_async()
                .setup().await
        }
    });

    // This should print,
    //
    // Hello World
    // Hello World 2
    //



    Ok(())
}

/// 
/// 
async fn entrypoint(disp: DispatchRef<'_, Properties>) -> DispatchResult<'_> {
    disp.enable_async()
        .call()
        .await
        // TODO -- Ensure doc comments are moved over to the extension trait,
        // .example1()?
        // .example2()?
        // .example3()?
        // .example4()?
        // .example5()?
        // .example1()?
        // .example6()?
        // .example4()
}

/// Enables logging
///
#[allow(dead_code)]
fn enable_logging() {
    use tracing_subscriber::EnvFilter;
    tracing_subscriber::fmt::Subscriber::builder()
        .with_env_filter(
            EnvFilter::builder()
                .from_env()
                .expect("should be able to build from env variables")
                .add_directive(
                    "reality::v2=trace"
                        .parse()
                        .expect("should be able to parse tracing settings"),
                ),
        )
        .init();
}
